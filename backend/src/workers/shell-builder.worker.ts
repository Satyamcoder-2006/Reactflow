import { Worker, Job } from 'bullmq';
import { prisma } from '../db/prisma';
import { DockerService } from '../services/docker.service';
import { env } from '../config/env';
import { logger } from '../utils/logger';
import { redis } from '../config/redis';
import path from 'path';
import fs from 'fs-extra';

const dockerService = new DockerService();

interface ShellBuildJob {
    buildId: string;
    repoId: string;
    userId: string;
    repoUrl: string;
    branch: string;
    commit: string;
}

export const shellBuilderWorker = new Worker<ShellBuildJob>(
    'shell-build',
    async (job: Job<ShellBuildJob>) => {
        const { buildId, repoId, repoUrl, branch, commit } = job.data;

        logger.info(`Starting shell build job for build ${buildId}`);

        try {
            // Update build status
            await prisma.build.update({
                where: { id: buildId },
                data: { status: 'BUILDING', startedAt: new Date() },
            });

            // Emit start event
            await redis.publish('build-events', JSON.stringify({
                type: 'build:started',
                buildId,
                repoId,
                timestamp: new Date().toISOString()
            }));

            // Listen to Docker logs
            const logBuffer: string[] = [];
            const BATCH_SIZE = 10;
            let batchTimeout: NodeJS.Timeout | null = null;

            const flushLogs = async () => {
                if (logBuffer.length === 0) return;
                const batch = logBuffer.splice(0, logBuffer.length);
                await prisma.buildLog.createMany({
                    data: batch.map(message => ({
                        buildId,
                        message: message.trim(),
                        level: 'INFO',
                    })),
                }).catch(err => logger.error('Failed to save build logs batch', err));

                await redis.publish('build-events', JSON.stringify({
                    type: 'build:log',
                    buildId,
                    message: batch[batch.length - 1]?.trim(),
                }));
            };

            const logListener = ({ buildId: logBuildId, message }: { buildId: string, message: string }) => {
                if (logBuildId === buildId) {
                    logBuffer.push(message);
                    if (logBuffer.length >= BATCH_SIZE) {
                        flushLogs();
                    } else if (!batchTimeout) {
                        batchTimeout = setTimeout(() => {
                            batchTimeout = null;
                            flushLogs();
                        }, 2000);
                    }
                }
            };

            dockerService.on('log', logListener);

            // Start build
            const startTime = Date.now();
            const apkUrl = await dockerService.buildShellAPK({
                repoId,
                repoUrl,
                branch,
                commit,
                buildId,
            });

            const buildTime = Math.floor((Date.now() - startTime) / 1000);

            // Flush remaining logs
            if (batchTimeout) clearTimeout(batchTimeout);
            await flushLogs();

            // Read metadata generated by build script
            const metadataPath = path.join(process.cwd(), 'uploads/shells', repoId, commit, 'build-info.json');
            let metadata = { apkSize: 0 };
            if (await fs.pathExists(metadataPath)) {
                metadata = await fs.readJSON(metadataPath);
            }

            // Update build
            await prisma.build.update({
                where: { id: buildId },
                data: {
                    status: 'SUCCESS',
                    completedAt: new Date(),
                    buildDuration: buildTime,
                    apkUrl,
                    apkSize: metadata.apkSize,
                },
            });

            // Update shell record or create if not exists
            await prisma.shell.upsert({
                where: { dependencyHash: buildId }, // Using buildId as mock dependencyHash for now
                create: {
                    dependencyHash: buildId,
                    apkUrl,
                    apkSize: metadata.apkSize,
                    buildTime: buildTime,
                    reactNativeVersion: 'resolved-during-build',
                    dependencies: {}, // Added required field
                },
                update: {
                    apkUrl,
                    apkSize: metadata.apkSize,
                    buildTime: buildTime,
                }
            });

            // Emit success
            await redis.publish('build-events', JSON.stringify({
                type: 'build:complete',
                buildId,
                repoId,
                apkUrl,
            }));

            dockerService.off('log', logListener);

            return { success: true, apkUrl };
        } catch (error: any) {
            logger.error(`Build ${buildId} failed:`, error);
            await prisma.build.update({
                where: { id: buildId },
                data: {
                    status: 'FAILED',
                    completedAt: new Date(),
                    error: error.message,
                    errorStack: error.stack,
                },
            });

            await redis.publish('build-events', JSON.stringify({
                type: 'build:failed',
                buildId,
                repoId,
                error: error.message,
            }));

            throw error;
        }
    },
    {
        connection: {
            host: env.REDIS_HOST || 'localhost',
            port: Number(env.REDIS_PORT) || 6379,
        },
        concurrency: Number(env.BUILD_CONCURRENCY) || 2,
    }
);
