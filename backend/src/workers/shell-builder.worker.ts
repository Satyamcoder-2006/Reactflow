import { Worker, Job } from 'bullmq';
import { WorkerContext } from './worker-auth';
import { SessionEventPublisher } from '../events/session-events';
import { DockerService } from '../services/docker.service';
import { EmulatorService } from '../services/emulator.service';
import { env } from '../config/env';
import { logger } from '../utils/logger';
import path from 'path';
import fs from 'fs-extra';

// Initialize context ONCE
WorkerContext.initialize().catch(err => {
    logger.error('Failed to initialize worker context:', err);
    process.exit(1);
});

const dockerService = new DockerService();
const emulatorService = new EmulatorService();

interface ShellBuildJob {
    buildId: string;
    repoId: string;
    userId: string;
    repoUrl: string;
    branch: string;
    commit: string;
    autoStartSession?: boolean;
}

export const shellBuilderWorker = new Worker<ShellBuildJob>(
    'shell-build',
    async (job: Job<ShellBuildJob>) => {
        const { buildId, repoId, userId, repoUrl, branch, commit, autoStartSession } = job.data;
        const prisma = WorkerContext.getPrisma();
        const redis = WorkerContext.getRedis();
        const eventPublisher = new SessionEventPublisher(redis);

        logger.info(`Starting shell build job for build ${buildId}`);

        try {
            // Update build status
            await prisma.build.update({
                where: { id: buildId },
                data: { status: 'BUILDING', startedAt: new Date() },
            });

            // Emit start event
            await redis.publish('build-events', JSON.stringify({
                type: 'build:started',
                buildId,
                repoId,
                userId,
                timestamp: new Date().toISOString()
            }));

            // Listen to Docker logs
            const logBuffer: string[] = [];
            const BATCH_SIZE = 10;
            let batchTimeout: NodeJS.Timeout | null = null;

            const flushLogs = async () => {
                if (logBuffer.length === 0) return;
                const batch = logBuffer.splice(0, logBuffer.length);
                await prisma.buildLog.createMany({
                    data: batch.map(message => ({
                        buildId,
                        message: message.replace(/\u0000/g, '').trim(),
                        level: 'INFO',
                    })),
                }).catch(err => {
                    logger.error(err, 'Failed to save build logs batch');
                });

                await redis.publish('build-events', JSON.stringify({
                    type: 'build:log',
                    buildId,
                    userId,
                    message: batch[batch.length - 1]?.trim(),
                }));
            };

            const logListener = ({ buildId: logBuildId, message }: { buildId: string, message: string }) => {
                if (logBuildId === buildId) {
                    logBuffer.push(message);
                    if (logBuffer.length >= BATCH_SIZE) {
                        flushLogs();
                    } else if (!batchTimeout) {
                        batchTimeout = setTimeout(() => {
                            batchTimeout = null;
                            flushLogs();
                        }, 2000);
                    }
                }
            };

            dockerService.on('log', logListener);

            // Start build
            const startTime = Date.now();
            const apkUrl = await dockerService.buildShellAPK({
                repoId,
                repoUrl,
                branch,
                commit,
                buildId,
            });

            const buildTime = Math.floor((Date.now() - startTime) / 1000);

            // Flush remaining logs
            if (batchTimeout) clearTimeout(batchTimeout);
            await flushLogs();

            // Read metadata generated by build script
            const metadataPath = path.join(process.cwd(), 'uploads/shells', repoId, commit, 'build-info.json');
            let metadata = { apkSize: 0 };
            if (await fs.pathExists(metadataPath)) {
                metadata = await fs.readJSON(metadataPath);
            }

            // Update build
            await prisma.build.update({
                where: { id: buildId },
                data: {
                    status: 'SUCCESS',
                    completedAt: new Date(),
                    buildDuration: buildTime,
                    apkUrl,
                    apkSize: metadata.apkSize,
                },
            });

            // Update shell record or create if not exists
            await prisma.shell.upsert({
                where: { dependencyHash: buildId }, // Using buildId as mock dependencyHash for now
                create: {
                    dependencyHash: buildId,
                    apkUrl,
                    apkSize: metadata.apkSize,
                    buildTime: buildTime,
                    reactNativeVersion: 'resolved-during-build',
                    dependencies: {},
                },
                update: {
                    apkUrl,
                    apkSize: metadata.apkSize,
                    buildTime: buildTime,
                }
            });

            // Emit success
            await redis.publish('build-events', JSON.stringify({
                type: 'build:complete',
                buildId,
                repoId,
                userId,
                apkUrl,
                timestamp: new Date().toISOString()
            }));

            dockerService.off('log', logListener);

            // Auto-start session if requested
            if (autoStartSession) {
                try {
                    // Check for existing session to avoid duplicates (Race condition handling)
                    const existingSession = await prisma.emulatorSession.findFirst({
                        where: {
                            repoId,
                            userId,
                            status: { in: ['STARTING', 'RUNNING'] }
                        }
                    });

                    if (existingSession) {
                        logger.info(`Session already exists for repo ${repoId}, triggering reload instead.`);
                        await eventPublisher.publishReload(existingSession.id, userId, buildId);
                    } else {
                        logger.info(`Auto-starting session for user ${userId} build ${buildId}`);
                        await emulatorService.createSession({
                            userId,
                            repoId,
                            shellId: buildId
                        });
                    }
                } catch (sessionError: any) {
                    logger.error('Failed to auto-start session after build:', sessionError);
                    await eventPublisher.publishError('pending', userId, 'AUTO_START_FAILED', sessionError.message);
                }
            }

            return { success: true, apkUrl };
        } catch (error: any) {
            logger.error({ err: error, buildId }, `Build ${buildId} failed`);
            await prisma.build.update({
                where: { id: buildId },
                data: {
                    status: 'FAILED',
                    completedAt: new Date(),
                    error: error.message,
                    errorStack: error.stack,
                },
            });

            await redis.publish('build-events', JSON.stringify({
                type: 'build:failed',
                buildId,
                repoId,
                userId,
                error: error.message,
                timestamp: new Date().toISOString()
            }));

            throw error;
        }
    },
    {
        connection: {
            host: env.REDIS_HOST || 'localhost',
            port: Number(env.REDIS_PORT) || 6379,
        },
        concurrency: Number(env.BUILD_CONCURRENCY) || 2,
    }
);
